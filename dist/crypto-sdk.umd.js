(function(u,m){typeof exports=="object"&&typeof module!="undefined"?module.exports=m(require("@metamask/eth-sig-util"),require("web3")):typeof define=="function"&&define.amd?define(["@metamask/eth-sig-util","web3"],m):(u=typeof globalThis!="undefined"?globalThis:u||self,u.cryptoSDK=m(u["@metamask/eth-sig-util"],u.Web3))})(this,function(u,m){"use strict";function F(e){return e&&typeof e=="object"&&"default"in e?e:{default:e}}var I=F(m);const U=e=>{document.addEventListener(v,e)},s=(e,t)=>{const n=new CustomEvent(v,{detail:{type:e,msg:t}});document.dispatchEvent(n)},r=(e,t)=>{const n=new CustomEvent(v,{detail:{type:e,msg:t,error:!0}});document.dispatchEvent(n)},a={network:"network",accountsChanged:"accountsChanged",chainChanged:"chainChanged",message:"message",address:"address",wrongNetworkOnGetAddress:"wrongNetworkOnGetAddress",metamaskNotInstalled:"metamaskNotInstalled",general:"general",claimNotSigned:"claimNotSigned",claimSigned:"claimSigned",claimConfirmed:"claimConfirmed",claimNotConfirmed:"claimNotConfirmed",winClaimSigned:"winClaimSigned",winNotConfirmed:"winNotConfirmed",challengeSigned:"challengeSigned",challengeNotSigned:"challengeNotSigned",claimSynced:"claimSynced",claimNotSynced:"claimNotSynced",token:"jwtToken",withdraw:"withdraw"},v="cryptoSDK",S="97",G="BSC Testnet",J="https://data-seed-prebsc-1-s1.binance.org",Y="https://testnet.bscscan.com/",j="BNB",z="BNB",X="18",l=async()=>{const e=D(),t=y();if(t){const n=Number(await t.request({method:"eth_chainId"}));if(Array.isArray(e)){if(e.includes(n))return!0;{const i="Please change your network on Metamask. Valid networks are: "+E(e);throw new Error(i)}}else if(Number(n)!==Number(e)){const i=`Please set your network on Metamask to ${E(e)}`;throw new Error(i)}else return!0}},E=(e=!1)=>{const t=[];if(t[1]="Ethereum Mainnet",t[3]="Ethereum Ropsten",t[42]="Ethereum Kovan",t[4]="Ethereum Rinkeby",t[5]="Ethereum Goerli",t[56]="Binance Smart Chain",t[97]="Binance Smart Chain Testnet",e)if(Array.isArray(e)){const n=[];for(let i=0;i<e.length;i++)n.push(t[e[i]]);return n}else return t[e]?t[e]:(console.error(`Network ID ${e} Not found in the networksNames list`),E(S));else return t},D=()=>[Number(S)],R=async()=>{try{const e=await l();return s(a.network,e),e}catch(e){return r(a.network,e),!1}},Q=async()=>{if(window.ethereum){const e=window.ethereum,n=[{chainId:`0x${Number(S).toString(16)}`,chainName:G,nativeCurrency:{name:j,symbol:z,decimals:X},rpcUrls:[J],blockExplorerUrls:[Y]}];try{await e.request({method:"wallet_addEthereumChain",params:n}),await l()?s(a.network,"Success, network is set to the right one"):r(a.network,"Add net error: network is not changed")}catch(i){r(a.network,`Add net error: ${i}`)}}else throw window.web3?(r(a.network,"This version of Metamask supports only manual network switching"),new Error("This version of Metamask supports only manual network switching")):(r(a.network,"Metamask is not installed"),new Error("Metamask is not installed"))},y=()=>{if(window.ethereum)return window.ethereum;if(window.web3)return window.web3.currentProvider;throw r(a.metamaskNotInstalled,{error:"Metamask is not installed"}),new Error("Metamask is not installed")},V=async e=>{try{await R()?s(a.chainChanged,{chainId:e}):r(a.chainChanged,{chainId:e})}catch{r(a.chainChanged,{chainId:e})}},Z=()=>{window.ethereum?(window.ethereum.chainId||(window.ethereum.chainId="97"),window.ethereum.on("accountsChanged",async e=>{console.log("#### - Metamask: accountsChanged - accounts",e),s(a.accountsChanged,{accounts:e})}),window.ethereum.on("chainChanged",async e=>{console.log("#### - Metamask: chainChanged",e),await V(e)}),window.ethereum.on("message",async e=>{s(a.message,{message:e})}),window.ethereum.on("error",async e=>{console.log("#### - Metamask: error",e),r(a.error,e)})):window.web3&&(window.web3.currentProvider.on("accountsChanged",async e=>{console.log("#### - Metamask web3: accountsChanged - accounts",e),s(a.accountsChanged,{accounts:e})}),window.web3.currentProvider.on("chainIdChanged",async e=>{console.log("#### - Metamask web3: chainChanged",e),await V(e)}),window.web3.currentProvider.on("error",async e=>{console.log("#### - Metamask web3: error",e),r(a.error,e)}))},ee=async()=>{if(window.ethereum){const e=await window.ethereum.request({method:"eth_requestAccounts"});if(e&&e[0])return e[0];throw new Error("Can't get address")}else if(window.web3){const e=window.web3.eth.accounts;if(e&&e.length>0)return e[0];throw new Error("Can't get address")}else throw new Error("Metamask is not installed")},M=()=>!!(window.ethereum||window.web3),te=async()=>{if(!M()){const t="Metamask is not installed, unable to get user address";throw r(a.metamaskNotInstalled,t),new Error(t)}const e=D();try{await l(e)}catch(t){throw r(a.wrongNetworkOnGetAddress,t),new Error(t)}try{return{address:await ee()}}catch(t){throw r(a.address,t),new Error(t)}},_=async(e,t)=>(await l(),await y().request({method:"eth_signTypedData_v4",params:[t,JSON.stringify(e)],from:t}));Z();const $={name:"BSC Testnet",version:"1",chainId:"97",verifyingContract:"0xA0Af3739fBC126C287D2fd0b5372d939Baa36B17"},ne=e=>({types:{EIP712Domain:[{name:"name",type:"string"},{name:"version",type:"string"},{name:"chainId",type:"uint256"},{name:"verifyingContract",type:"address"}],Signin:[{name:"method",type:"string"},{name:"text",type:"string"}]},domain:$,primaryType:"Signin",message:{method:"signin",text:e}}),ae=async(e,t)=>{const n=ne(e);try{const i=await _(n,t);return s(a.challengeSigned,{signature:i}),i}catch(i){throw r(a.challengeNotSigned,i),i}},x="authToken",B="expireToken",ie=12e5,re=e=>{try{localStorage.setItem(x,e),localStorage.setItem(B,Date.now()+ie),s(a.token,"JWT token received")}catch(t){r(a.token,t)}},W=()=>localStorage.getItem(x);var f={signChallenge:ae,setToken:re,getToken:W,isLogged:()=>{if(W()){const t=localStorage.getItem(B);if(t&&t>Date.now())return!0}return!1}};const C={claimConfirmed:"claimConfirmed",claimAlice:"claimAlice"};var c={saveConfirmedClaim:e=>{localStorage.setItem(C.claimConfirmed,JSON.stringify(e))},getConfirmedClaim:()=>JSON.parse(localStorage.getItem(C.claimConfirmed)),saveClaimAlice:e=>{localStorage.setItem(C.claimAlice,JSON.stringify(e))},getClaimAlice:()=>JSON.parse(localStorage.getItem(C.claimAlice))};const b="0xeA085D9698651e76750F07d0dE0464476187b3ca",q=e=>{const t=c.getConfirmedClaim();if(t){if(t.id!==e.id)throw new Error(`Invalid claim id: ${e.id} - last claim id: ${t.id}`);if(t.nonce+1!==e.nonce)throw new Error(`Invalid claim nonce: ${e.nonce} - last claim nonce: ${t.nonce}`);if(e.addresses[1]!==b)throw new Error(`Invalid address of Server: ${e.addresses[1]} - expected: ${b}`);const i=t.cumulativeDebits[1]-t.cumulativeDebits[0]+e.amount;P(i,e.cumulativeDebits)}else{if(e.id!==1)throw new Error(`Invalid claim id: ${e.id}`);if(e.nonce!==1)throw new Error(`Invalid claim nonce: ${e.nonce}`);if(e.addresses[1]!==b)throw new Error(`Invalid address of Server: ${e.addresses[1]} - expected: ${b}`);const n=e.amount;P(n,e.cumulativeDebits)}return!0},P=(e,t)=>{if(e>0){if(t[0]!==0)throw new Error(`Invalid claim cumulative debit of Client: ${t[0]} - expected: 0`);if(t[1]!==e)throw new Error(`Invalid claim cumulative debit of Server: ${t[1]} - expected: ${e}`)}else{if(t[0]!==-e)throw new Error(`Invalid claim cumulative debit of Client: ${t[0]} - expected: ${-e}`);if(t[1]!==0)throw new Error(`Invalid claim cumulative debit of Server: ${t[1]} - expected: 0`)}},se=e=>{let t=q(e);if(t){const n=c.getClaimAlice();n&&(t=k(e,n))}return t},k=(e,t,n=!1)=>{if(t.id!==e.id)throw new Error(`Invalid claim id: ${e.id} - saved claim id: ${t.id}`);const i=n?e.nonce-1:e.nonce;if(t.nonce!==i)throw new Error(`Invalid claim nonce: ${e.nonce} - saved claim nonce: ${t.nonce}`);if(t.cumulativeDebits[0]!==e.cumulativeDebits[0])throw new Error(`Invalid claim cumulative debit of Client: ${e.cumulativeDebits[0]} - saved claim: ${t.cumulativeDebits[0]}`);if(t.cumulativeDebits[1]!==e.cumulativeDebits[1])throw new Error(`Invalid claim cumulative debit of Server: ${e.cumulativeDebits[1]} - saved claim: ${t.cumulativeDebits[1]}`);const d=n?"wallet.withdraw":t.type;if(e.type!==d)throw new Error(`Invalid claim type: ${e.type} - saved claim type: ${t.type}`);if(t.addresses[0]!==e.addresses[0])throw new Error(`Invalid address of Client: ${e.addresses[0]} - saved claim: ${t.addresses[0]}`);if(t.addresses[1]!==e.addresses[1])throw new Error(`Invalid address of Server: ${e.addresses[1]} - saved claim: ${t.addresses[1]}`);if(!n&&t.timestamp!==e.timestamp)throw new Error(`Invalid timestamp of Server: ${e.timestamp} - saved claim: ${t.timestamp}`);return!0};var p={isValidNewClaim:q,isValidClaimAlice:se,areEqualClaims:k,isValidWithdraw:e=>{const t=c.getConfirmedClaim();return t?k(e,t,!0):!1}},oe=[{anonymous:!1,inputs:[{components:[{components:[{internalType:"uint256",name:"id",type:"uint256"},{internalType:"uint256",name:"nonce",type:"uint256"},{internalType:"uint256",name:"timestamp",type:"uint256"},{internalType:"uint256[]",name:"cumulativeDebits",type:"uint256[]"}],internalType:"struct VaultV1.ClaimTransaction",name:"claimTransaction",type:"tuple"},{internalType:"uint256",name:"timestamp",type:"uint256"},{internalType:"address",name:"requester",type:"address"}],indexed:!1,internalType:"struct VaultV1.EmergencyWithdrawRequest",name:"emergencyWithdrawRequest",type:"tuple"}],name:"InitEmergencyWithdraw",type:"event"},{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"previousAdminRole",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"newAdminRole",type:"bytes32"}],name:"RoleAdminChanged",type:"event"},{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleGranted",type:"event"},{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleRevoked",type:"event"},{anonymous:!1,inputs:[{components:[{components:[{internalType:"uint256",name:"id",type:"uint256"},{internalType:"uint256",name:"nonce",type:"uint256"},{internalType:"uint256",name:"timestamp",type:"uint256"},{internalType:"uint256[]",name:"cumulativeDebits",type:"uint256[]"}],internalType:"struct VaultV1.ClaimTransaction",name:"claimTransaction",type:"tuple"},{internalType:"uint256",name:"timestamp",type:"uint256"},{internalType:"address",name:"requester",type:"address"}],indexed:!1,internalType:"struct VaultV1.EmergencyWithdrawRequest",name:"emergencyWithdrawRequest",type:"tuple"},{indexed:!1,internalType:"string",name:"cause",type:"string"}],name:"StopEmergencyWithdraw",type:"event"},{anonymous:!1,inputs:[{components:[{internalType:"uint256",name:"id",type:"uint256"},{internalType:"uint256",name:"nonce",type:"uint256"},{internalType:"uint256",name:"timestamp",type:"uint256"},{internalType:"uint256[]",name:"cumulativeDebits",type:"uint256[]"}],indexed:!1,internalType:"struct VaultV1.ClaimTransaction",name:"claimTransaction",type:"tuple"}],name:"Withdraw",type:"event"},{inputs:[],name:"DEFAULT_ADMIN_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},{inputs:[{internalType:"address",name:"clientAddress",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},{inputs:[{internalType:"address",name:"",type:"address"}],name:"balances",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},{inputs:[{internalType:"uint256",name:"amount",type:"uint256"}],name:"deposit",outputs:[],stateMutability:"nonpayable",type:"function"},{inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"depositFor",outputs:[],stateMutability:"nonpayable",type:"function"},{inputs:[],name:"emergencyWithdrawAlice",outputs:[],stateMutability:"nonpayable",type:"function"},{inputs:[{internalType:"address",name:"",type:"address"}],name:"emergencyWithdrawRequests",outputs:[{components:[{internalType:"uint256",name:"id",type:"uint256"},{internalType:"uint256",name:"nonce",type:"uint256"},{internalType:"uint256",name:"timestamp",type:"uint256"},{internalType:"uint256[]",name:"cumulativeDebits",type:"uint256[]"}],internalType:"struct VaultV1.ClaimTransaction",name:"claimTransaction",type:"tuple"},{internalType:"uint256",name:"timestamp",type:"uint256"},{internalType:"address",name:"requester",type:"address"}],stateMutability:"view",type:"function"},{inputs:[],name:"getChainId",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"}],name:"getRoleAdmin",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"grantRole",outputs:[],stateMutability:"nonpayable",type:"function"},{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"hasRole",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},{inputs:[{components:[{internalType:"uint256",name:"id",type:"uint256"},{internalType:"address[]",name:"addresses",type:"address[]"},{internalType:"uint256",name:"nonce",type:"uint256"},{internalType:"uint256",name:"timestamp",type:"uint256"},{internalType:"string",name:"messageForAlice",type:"string"},{internalType:"uint256[]",name:"cumulativeDebits",type:"uint256[]"},{internalType:"bytes[]",name:"signatures",type:"bytes[]"}],internalType:"struct VaultV1.ClaimRequest",name:"req",type:"tuple"}],name:"initEmergencyWithdrawAlice",outputs:[],stateMutability:"nonpayable",type:"function"},{inputs:[],name:"initEmergencyWithdrawAliceWithoutClaim",outputs:[],stateMutability:"nonpayable",type:"function"},{inputs:[{internalType:"address",name:"alice",type:"address"}],name:"initEmergencyWithdrawBob",outputs:[],stateMutability:"nonpayable",type:"function"},{inputs:[{internalType:"address",name:"tokenAddress",type:"address"},{internalType:"address",name:"serverAddress",type:"address"},{internalType:"string",name:"name",type:"string"},{internalType:"string",name:"version",type:"string"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function"},{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"renounceRole",outputs:[],stateMutability:"nonpayable",type:"function"},{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"revokeRole",outputs:[],stateMutability:"nonpayable",type:"function"},{inputs:[{components:[{internalType:"uint256",name:"id",type:"uint256"},{internalType:"address[]",name:"addresses",type:"address[]"},{internalType:"uint256",name:"nonce",type:"uint256"},{internalType:"uint256",name:"timestamp",type:"uint256"},{internalType:"string",name:"messageForAlice",type:"string"},{internalType:"uint256[]",name:"cumulativeDebits",type:"uint256[]"},{internalType:"bytes[]",name:"signatures",type:"bytes[]"}],internalType:"struct VaultV1.ClaimRequest",name:"req",type:"tuple"}],name:"stopEmergencyWithdraw",outputs:[],stateMutability:"nonpayable",type:"function"},{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},{inputs:[{components:[{internalType:"uint256",name:"id",type:"uint256"},{internalType:"address[]",name:"addresses",type:"address[]"},{internalType:"uint256",name:"nonce",type:"uint256"},{internalType:"uint256",name:"timestamp",type:"uint256"},{internalType:"string",name:"messageForAlice",type:"string"},{internalType:"uint256[]",name:"cumulativeDebits",type:"uint256[]"},{internalType:"bytes[]",name:"signatures",type:"bytes[]"}],internalType:"struct VaultV1.ClaimRequest",name:"req",type:"tuple"}],name:"verify",outputs:[],stateMutability:"view",type:"function"},{inputs:[{components:[{internalType:"uint256",name:"id",type:"uint256"},{internalType:"address[]",name:"addresses",type:"address[]"},{internalType:"uint256",name:"nonce",type:"uint256"},{internalType:"uint256",name:"timestamp",type:"uint256"},{internalType:"string",name:"messageForAlice",type:"string"},{internalType:"uint256[]",name:"cumulativeDebits",type:"uint256[]"},{internalType:"bytes[]",name:"signatures",type:"bytes[]"}],internalType:"struct VaultV1.ClaimRequest",name:"req",type:"tuple"}],name:"withdrawAlice",outputs:[],stateMutability:"nonpayable",type:"function"},{inputs:[{internalType:"address",name:"",type:"address"}],name:"withdrawTransactions",outputs:[{internalType:"uint256",name:"id",type:"uint256"},{internalType:"uint256",name:"nonce",type:"uint256"},{internalType:"uint256",name:"timestamp",type:"uint256"}],stateMutability:"view",type:"function"}];const ce="0xA0Af3739fBC126C287D2fd0b5372d939Baa36B17",K=(e,t=ce,n=oe)=>{const i=new I.default(e);return new i.eth.Contract(n,t)},le=async(e,t,n)=>await e.methods[t](n).call();var N={getVaultBalance:async(e,t)=>{const n=K(t);return{balance:await le(n,"balanceOf",e)}},withdrawConsensually:async(e,t)=>{const n=K(t),i=new I.default(t),d=e.addresses[0];try{const g=await n.methods.withdrawAlice(e).estimateGas({from:d}),pe={gasPrice:await i.eth.getGasPrice(),from:d,gas:g};try{await n.methods.withdrawAlice(e).send(pe).on("transactionHash",h=>{console.log("txHash",h)}).on("receipt",h=>{console.log("receipt",h)})}catch(h){throw new Error(h)}}catch(g){throw new Error(g)}}};const ue=async(e,t)=>{if(await p.isValidNewClaim(e)){if(!T(e))throw new Error("Server's signature is not verified");if(await H(e,t)===!0)return await A(e),c.saveConfirmedClaim(e),e;throw new Error("Server's balance is not enough")}},O=e=>({types:{EIP712Domain:[{name:"name",type:"string"},{name:"version",type:"string"},{name:"chainId",type:"uint256"},{name:"verifyingContract",type:"address"}],Claim:[{name:"id",type:"uint256"},{name:"alice",type:"address"},{name:"bob",type:"address"},{name:"nonce",type:"uint256"},{name:"timestamp",type:"uint256"},{name:"messageForAlice",type:"string"},{name:"cumulativeDebitAlice",type:"uint256"},{name:"cumulativeDebitBob",type:"uint256"}]},domain:$,primaryType:"Claim",message:{id:e.id,alice:e.addresses[0],bob:e.addresses[1],nonce:e.nonce,timestamp:e.timestamp,messageForAlice:e.messageForAlice,cumulativeDebitAlice:e.cumulativeDebits[0],cumulativeDebitBob:e.cumulativeDebits[1]}}),T=(e,t=!1)=>{let n=1;t&&(n=0);const i=O(e),d=e.signatures[n];try{return u.recoverTypedSignature({data:i,signature:d,version:u.SignTypedDataVersion.V4}).toUpperCase()===e.addresses[n].toUpperCase()}catch{return!1}},de=async(e,t)=>{const n=await L(e);if(await p.isValidNewClaim(e)&&n){if(await H(e,t)===!0)return await A(e),c.saveClaimAlice(e),e;throw new Error("Not enough balance")}},L=e=>{const t=c.getClaimAlice();if(t&&t.id===e.id&&t.nonce>=e.nonce)throw new Error(`Claim with nonce ${e.nonce} is already signed`);return!0},H=async(e,t)=>{const n=e.amount<0?0:1;return n===1?!0:await ye(e,n,t)},ye=async(e,t,n)=>{try{const{balance:i}=await N.getVaultBalance(e.addresses[t],n);return i>=e.cumulativeDebits[t]}catch{throw new Error("Can't get balance from Vault")}},A=async e=>{const t=O(e),n=e.addresses[0];e.signatures[0]=await _(t,n)};var w={pay:de,payReceived:async e=>{if(p.isValidClaimAlice(e))if(T(e))c.saveConfirmedClaim(e);else throw new Error("Server's signature is not verified")},win:ue,signWithdraw:async(e,t)=>{const n=L(e);if(p.isValidWithdraw(e)&&n)return await A(e),c.saveClaimAlice(e),e},lastClaim:e=>{const t=c.getConfirmedClaim();if(!t&&e===null)return!0;if(!t&&e&&e.nonce)return c.saveConfirmedClaim(e),!0;if(t&&e===null)return{handshake:t};if(e.id>=t.id&&e.nonce>t.nonce)return T(e,!0)&&T(e)?(c.saveConfirmedClaim(e),!0):{handshake:t};try{return p.areEqualClaims(e,t)===!0&&e.signatures[0]===t.signatures[0]&&e.signatures[1]===t.signatures[1]?!0:{handshake:t}}catch{return{handshake:t}}}},o={pay:async e=>{try{await l()}catch(n){throw r(a.claimNotSigned,n),n}const t=y();try{const n=await w.pay(e,t);return s(a.claimSigned,{claim:n}),n}catch(n){throw r(a.claimNotSigned,n),n}},payReceived:async e=>{try{await l()}catch(t){throw r(a.claimNotConfirmed,t),t}try{await w.payReceived(e),s(a.claimConfirmed,{claim:e})}catch(t){throw r(a.claimNotConfirmed,{error:t,claim:e}),t}},win:async e=>{try{await l()}catch(n){throw r(a.winNotConfirmed,n),n}const t=y();try{const n=await w.win(e,t);return s(a.winClaimSigned,{claim:n}),n}catch(n){throw r(a.winNotConfirmed,n),n}},lastClaim:e=>{if(e&&e.hasOwnProperty("error")){r(a.claimNotSynced,e.error);return}const t=w.lastClaim(e);if(t===!0)s(a.claimSynced,"Claims are synced");else return r(a.claimNotSynced,{lastClaim:t}),t},signWithdraw:async e=>{try{await l()}catch(n){throw r(a.claimNotSigned,n),n}const t=y();try{const n=await w.signWithdraw(e,t);return s(a.claimSigned,{claim:n}),n}catch(n){throw r(a.claimNotSigned,n),n}},withdrawConsensually:async e=>{try{await l()}catch(n){throw r(a.withdraw,n),n}const t=y();try{await N.withdrawConsensually(e,t),s(a.withdraw,"Consensual withdraw is sent to blockchain")}catch(n){r(a.withdraw,n)}},getVaultBalance:async e=>{const t=y();try{return await N.getVaultBalance(e,t)}catch(n){console.error(n)}}};const me=async e=>{if(e){const t=JSON.parse(e);if(t.hasOwnProperty("handshake"))return o.lastClaim(t.handshake);{const n=t;if(n&&n.type==="ticket.play"){if(!n.signatures[0]&&!n.signatures[1])return await o.pay(n);n.signatures[0]&&n.signatures[1]&&await o.payReceived(n)}else if(n&&n.type==="ticket.win"){if(!n.signatures[0]&&n.signatures[1])return await o.win(n)}else if(n&&n.type==="wallet.withdraw"){if(!n.signatures[0]&&!n.signatures[1])return await o.signWithdraw(n);n.signatures[0]&&n.signatures[1]&&(await o.payReceived(n),await o.withdrawConsensually(n))}}}};return{getAddress:te,isMetamaskInstalled:M,isRightNet:R,setRightNet:Q,addEventListener:U,pay:o.pay,payReceived:o.payReceived,win:o.win,receiveMsg:me,signChallenge:f.signChallenge,setToken:f.setToken,getToken:f.getToken,isLogged:f.isLogged,lastClaim:o.lastClaim,getVaultBalance:o.getVaultBalance}});
