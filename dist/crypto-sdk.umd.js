(function(m,h){typeof exports=="object"&&typeof module!="undefined"?module.exports=h(require("@metamask/eth-sig-util"),require("bignumber.js"),require("web3")):typeof define=="function"&&define.amd?define(["@metamask/eth-sig-util","bignumber.js","web3"],h):(m=typeof globalThis!="undefined"?globalThis:m||self,m.cryptoSDK=h(m["@metamask/eth-sig-util"],m.bignumber.js,m.Web3))})(this,function(m,h,te){"use strict";function V(e){return e&&typeof e=="object"&&"default"in e?e:{default:e}}var s=V(h),x=V(te);const ne=e=>{document.addEventListener(k,e)},l=(e,t)=>{const n=new CustomEvent(k,{detail:{type:e,msg:t}});document.dispatchEvent(n)},i=(e,t)=>{const n=new CustomEvent(k,{detail:{type:e,msg:t,error:!0}});document.dispatchEvent(n)},r={network:"network",accountsChanged:"accountsChanged",chainChanged:"chainChanged",message:"message",address:"address",wrongNetworkOnGetAddress:"wrongNetworkOnGetAddress",metamaskNotInstalled:"metamaskNotInstalled",general:"general",claimNotSigned:"claimNotSigned",claimSigned:"claimSigned",claimConfirmed:"claimConfirmed",claimNotConfirmed:"claimNotConfirmed",winClaimSigned:"winClaimSigned",winNotConfirmed:"winNotConfirmed",challengeSigned:"challengeSigned",challengeNotSigned:"challengeNotSigned",claimSynced:"claimSynced",claimNotSynced:"claimNotSynced",token:"jwtToken",withdraw:"withdraw"},k="cryptoSDK",D="97",ae="BSC Testnet",re="https://data-seed-prebsc-1-s1.binance.org",se="https://testnet.bscscan.com/",ie="BNB",oe="BNB",ce="18",y=async()=>{const e=q(),t=w();if(t){const n=Number(await t.request({method:"eth_chainId"}));if(Array.isArray(e)){if(e.includes(n))return!0;{const a="Please change your network on Metamask. Valid networks are: "+_(e);throw new Error(a)}}else if(Number(n)!==Number(e)){const a=`Please set your network on Metamask to ${_(e)}`;throw new Error(a)}else return!0}},_=(e=!1)=>{const t=[];if(t[1]="Ethereum Mainnet",t[3]="Ethereum Ropsten",t[42]="Ethereum Kovan",t[4]="Ethereum Rinkeby",t[5]="Ethereum Goerli",t[56]="Binance Smart Chain",t[97]="Binance Smart Chain Testnet",e)if(Array.isArray(e)){const n=[];for(let a=0;a<e.length;a++)n.push(t[e[a]]);return n}else return t[e]?t[e]:(console.error(`Network ID ${e} Not found in the networksNames list`),_(D));else return t},q=()=>[Number(D)],P=async()=>{try{const e=await y();return l(r.network,e),e}catch(e){return i(r.network,e),!1}},le=async()=>{if(window.ethereum){const e=window.ethereum,n=[{chainId:`0x${Number(D).toString(16)}`,chainName:ae,nativeCurrency:{name:ie,symbol:oe,decimals:ce},rpcUrls:[re],blockExplorerUrls:[se]}];try{await e.request({method:"wallet_addEthereumChain",params:n}),await y()?l(r.network,"Success, network is set to the right one"):i(r.network,"Add net error: network is not changed")}catch(a){i(r.network,`Add net error: ${a}`)}}else throw window.web3?(i(r.network,"This version of Metamask supports only manual network switching"),new Error("This version of Metamask supports only manual network switching")):(i(r.network,"Metamask is not installed"),new Error("Metamask is not installed"))},w=()=>{if(window.ethereum)return window.ethereum;if(window.web3)return window.web3.currentProvider;throw i(r.metamaskNotInstalled,{error:"Metamask is not installed"}),new Error("Metamask is not installed")},W=async e=>{try{await P()?l(r.chainChanged,{chainId:e}):i(r.chainChanged,{chainId:e})}catch{i(r.chainChanged,{chainId:e})}},ue=()=>{window.ethereum?(window.ethereum.chainId||(window.ethereum.chainId="97"),window.ethereum.on("accountsChanged",async e=>{console.log("#### - Metamask: accountsChanged - accounts",e),l(r.accountsChanged,{accounts:e})}),window.ethereum.on("chainChanged",async e=>{console.log("#### - Metamask: chainChanged",e),await W(e)}),window.ethereum.on("message",async e=>{l(r.message,{message:e})}),window.ethereum.on("error",async e=>{console.log("#### - Metamask: error",e),i(r.error,e)})):window.web3&&(window.web3.currentProvider.on("accountsChanged",async e=>{console.log("#### - Metamask web3: accountsChanged - accounts",e),l(r.accountsChanged,{accounts:e})}),window.web3.currentProvider.on("chainIdChanged",async e=>{console.log("#### - Metamask web3: chainChanged",e),await W(e)}),window.web3.currentProvider.on("error",async e=>{console.log("#### - Metamask web3: error",e),i(r.error,e)}))},de=async()=>{if(window.ethereum){const e=await window.ethereum.request({method:"eth_requestAccounts"});if(e&&e[0])return e[0];throw new Error("Can't get address")}else if(window.web3){const e=window.web3.eth.accounts;if(e&&e.length>0)return e[0];throw new Error("Can't get address")}else throw new Error("Metamask is not installed")},K=()=>!!(window.ethereum||window.web3),me=async()=>{if(!K()){const t="Metamask is not installed, unable to get user address";throw i(r.metamaskNotInstalled,t),new Error(t)}const e=q();try{await y(e)}catch(t){throw i(r.wrongNetworkOnGetAddress,t),new Error(t)}try{return{address:await de()}}catch(t){throw i(r.address,t),new Error(t)}},O=async(e,t)=>(await y(),await w().request({method:"eth_signTypedData_v4",params:[t,JSON.stringify(e)],from:t}));ue();const L={name:"BSC Testnet",version:"1",chainId:"97",verifyingContract:"0xA0Af3739fBC126C287D2fd0b5372d939Baa36B17"},ye=e=>({types:{EIP712Domain:[{name:"name",type:"string"},{name:"version",type:"string"},{name:"chainId",type:"uint256"},{name:"verifyingContract",type:"address"}],Signin:[{name:"method",type:"string"},{name:"text",type:"string"}]},domain:L,primaryType:"Signin",message:{method:"signin",text:e}}),pe=async(e,t)=>{const n=ye(e);try{const a=await O(n,t);return l(r.challengeSigned,{signature:a}),a}catch(a){throw i(r.challengeNotSigned,a),a}},F="authToken",H="expireToken",we=12e5,ge=e=>{try{localStorage.setItem(F,e),localStorage.setItem(H,Date.now()+we),l(r.token,"JWT token received")}catch(t){i(r.token,t)}},U=()=>localStorage.getItem(F);var v={signChallenge:pe,setToken:ge,getToken:U,isLogged:()=>{if(U()){const t=localStorage.getItem(H);if(t&&t>Date.now())return!0}return!1}};const f={claimConfirmed:"claimConfirmed",claimAlice:"claimAlice"},he=e=>{localStorage.setItem(f.claimConfirmed,JSON.stringify(e))},fe=()=>JSON.parse(localStorage.getItem(f.claimConfirmed)),Ce=e=>{localStorage.setItem(f.claimAlice,JSON.stringify(e))},be=()=>JSON.parse(localStorage.getItem(f.claimAlice)),Te=()=>{const e=localStorage.getItem(f.claimConfirmed);if(!e)return;const t=ve(e),n=document.createElement("a"),a=`lastConfirmedClaim-${new Date().toISOString()}.json`;n.setAttribute("href","data:application/json;charset=utf-8,"+encodeURIComponent(t)),n.setAttribute("download",a),n.style.display="none",document.body.appendChild(n),n.click(),document.body.removeChild(n)},ve=e=>(e=e.replace("{",`{
`),e=e.replace("}",`
}`),e=e.replaceAll(",",`,
`),e);var u={saveConfirmedClaim:he,getConfirmedClaim:fe,saveClaimAlice:Ce,getClaimAlice:be,downloadLastClaim:Te};const Ne=(e,t=2)=>new s.default(e+"").toFixed(t),Se=(e,t)=>{const n=new s.default(e+""),a=new s.default(t+"");return n.minus(a).toFixed()},Y=(e,t)=>{const n=new s.default(e+""),a=new s.default(t+"");return n.plus(a).toFixed()},Ee=(e,t=2)=>new s.default(e+"").toFixed(t),I=e=>{if(e==="0"||e===0)return"10";if(G(e,1)){const n=e.replace("0.","").length;console.log("l",n);const a=J(10,n);console.log({p:a});const c=N(e,a);console.log({b:c});const o=I(c);console.log({c:o});const b=S(o,a);return console.log({d:b}),b}else{const t=N(S(e,10,0,s.default.ROUND_UP),10);return t===e+""?I(Y(e,1)):t}},N=(e,t,n=18,a=s.default.ROUND_FLOOR)=>{let c=new s.default(e+"");const o=new s.default(t+"");return c=c.times(o).toFixed(),n=parseInt(n),B(c,n,a)},Ae=(e,t,n=18)=>N(e,t,n),S=(e,t,n=18,a=s.default.ROUND_FLOOR)=>{let c=new s.default(e+"");const o=new s.default(t+"");return c=c.div(o).toFixed(),n=parseInt(n),B(c,n,a)},ke=(e,t,n=18)=>S(e,t,n),J=(e,t)=>{const n=new s.default(e+""),a=new s.default(t+"");return n.pow(a)},De=(e,t)=>{const n=new s.default(e+""),a=new s.default(t+"");return n.eq(a)},G=(e,t)=>{const n=new s.default(e+""),a=new s.default(t+"");return n.lt(a)},_e=(e,t)=>{const n=new s.default(e+""),a=new s.default(t+"");return n.gt(a)},Ie=(e,t)=>{const n=new s.default(e+""),a=new s.default(t+"");return n.lte(a)},Be=(e,t)=>{const n=new s.default(e+""),a=new s.default(t+"");return n.gte(a)},Re=e=>new s.default(e+"").isNaN(),B=(e,t,n)=>new s.default(e+"").dp(parseInt(t),n).toFixed();var p={minus:Se,plus:Y,times:N,div:S,pow:J,eq:De,lt:G,gt:_e,lte:Ie,gte:Be,isNaN:Re,dp:B,negated:e=>new s.default(e+"").negated().toFixed(),timesFloor:Ae,divFloor:ke,toFixed:Ne,roundUpToTen:I,roundDecimals:Ee};const E="0xeA085D9698651e76750F07d0dE0464476187b3ca",j=e=>{const t=u.getConfirmedClaim();if(t){const n=t.closed===1,a=n?t.id+1:t.id,c=n?1:t.nonce+1;if(a!==e.id)throw new Error(`Invalid claim id: ${e.id} - last claim id: ${t.id}${n?". id must change after withdraw":""}`);if(c!==e.nonce)throw new Error(`Invalid claim nonce: ${e.nonce} ${n?" - channel id is changed":`- last claim nonce: ${t.nonce}`}`);if(e.addresses[1]!==E)throw new Error(`Invalid address of Server: ${e.addresses[1]} - expected: ${E}`);const o=p.minus(t.cumulativeDebits[1],t.cumulativeDebits[0]),b=p.plus(o,e.amount);z(b,e.cumulativeDebits)}else{if(e.id!==1)throw new Error(`Invalid claim id: ${e.id}`);if(e.nonce!==1)throw new Error(`Invalid claim nonce: ${e.nonce}`);if(e.addresses[1]!==E)throw new Error(`Invalid address of Server: ${e.addresses[1]} - expected: ${E}`);const n=e.amount;z(n,e.cumulativeDebits)}return!0},z=(e,t)=>{if(p.gt(e,0)){if(!p.eq(t[0],0))throw new Error(`Invalid claim cumulative debit of Client: ${t[0]} - expected: 0`);if(!p.eq(t[1],e))throw new Error(`Invalid claim cumulative debit of Server: ${t[1]} - expected: ${e}`)}else{if(!p.eq(t[0],p.negated(e)))throw new Error(`Invalid claim cumulative debit of Client: ${t[0]} - expected: ${-e}`);if(!p.eq(t[1],0))throw new Error(`Invalid claim cumulative debit of Server: ${t[1]} - expected: 0`)}},Me=e=>{let t=j(e);if(t){const n=u.getClaimAlice();n&&(t=R(e,n))}return t},R=(e,t,n=!1)=>{if(t.id!==e.id)throw new Error(`Invalid claim id: ${e.id} - saved claim id: ${t.id}`);const a=n?e.nonce-1:e.nonce;if(t.nonce!==a)throw new Error(`Invalid claim nonce: ${e.nonce} - saved claim nonce: ${t.nonce}`);if(t.addresses[0]!==e.addresses[0])throw new Error(`Invalid address of Client: ${e.addresses[0]} - saved claim: ${t.addresses[0]}`);if(t.addresses[1]!==e.addresses[1])throw new Error(`Invalid address of Server: ${e.addresses[1]} - saved claim: ${t.addresses[1]}`);if(t.cumulativeDebits[0]!==e.cumulativeDebits[0])throw new Error(`Invalid claim cumulative debit of Client: ${e.cumulativeDebits[0]} - saved claim: ${t.cumulativeDebits[0]}`);if(t.cumulativeDebits[1]!==e.cumulativeDebits[1])throw new Error(`Invalid claim cumulative debit of Server: ${e.cumulativeDebits[1]} - saved claim: ${t.cumulativeDebits[1]}`);if(!n&&t.timestamp!==e.timestamp)throw new Error(`Invalid timestamp of Server: ${e.timestamp} - saved claim: ${t.timestamp}`);return!0};var C={isValidNewClaim:j,isValidClaimAlice:Me,areEqualClaims:R,isValidWithdraw:e=>{const t=u.getConfirmedClaim();return t?R(e,t,!0):!1}},$e=[{anonymous:!1,inputs:[{components:[{components:[{internalType:"uint256",name:"id",type:"uint256"},{internalType:"uint256",name:"nonce",type:"uint256"},{internalType:"uint256",name:"timestamp",type:"uint256"},{internalType:"uint256[]",name:"cumulativeDebits",type:"uint256[]"}],internalType:"struct VaultV1.ClaimTransaction",name:"claimTransaction",type:"tuple"},{internalType:"uint256",name:"timestamp",type:"uint256"},{internalType:"address",name:"requester",type:"address"}],indexed:!1,internalType:"struct VaultV1.EmergencyWithdrawRequest",name:"emergencyWithdrawRequest",type:"tuple"}],name:"InitEmergencyWithdraw",type:"event"},{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"previousAdminRole",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"newAdminRole",type:"bytes32"}],name:"RoleAdminChanged",type:"event"},{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleGranted",type:"event"},{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleRevoked",type:"event"},{anonymous:!1,inputs:[{components:[{components:[{internalType:"uint256",name:"id",type:"uint256"},{internalType:"uint256",name:"nonce",type:"uint256"},{internalType:"uint256",name:"timestamp",type:"uint256"},{internalType:"uint256[]",name:"cumulativeDebits",type:"uint256[]"}],internalType:"struct VaultV1.ClaimTransaction",name:"claimTransaction",type:"tuple"},{internalType:"uint256",name:"timestamp",type:"uint256"},{internalType:"address",name:"requester",type:"address"}],indexed:!1,internalType:"struct VaultV1.EmergencyWithdrawRequest",name:"emergencyWithdrawRequest",type:"tuple"},{indexed:!1,internalType:"string",name:"cause",type:"string"}],name:"StopEmergencyWithdraw",type:"event"},{anonymous:!1,inputs:[{components:[{internalType:"uint256",name:"id",type:"uint256"},{internalType:"uint256",name:"nonce",type:"uint256"},{internalType:"uint256",name:"timestamp",type:"uint256"},{internalType:"uint256[]",name:"cumulativeDebits",type:"uint256[]"}],indexed:!1,internalType:"struct VaultV1.ClaimTransaction",name:"claimTransaction",type:"tuple"}],name:"Withdraw",type:"event"},{inputs:[],name:"DEFAULT_ADMIN_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},{inputs:[{internalType:"address",name:"clientAddress",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},{inputs:[{internalType:"address",name:"",type:"address"}],name:"balances",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},{inputs:[{internalType:"uint256",name:"amount",type:"uint256"}],name:"deposit",outputs:[],stateMutability:"nonpayable",type:"function"},{inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"depositFor",outputs:[],stateMutability:"nonpayable",type:"function"},{inputs:[],name:"emergencyWithdrawAlice",outputs:[],stateMutability:"nonpayable",type:"function"},{inputs:[{internalType:"address",name:"",type:"address"}],name:"emergencyWithdrawRequests",outputs:[{components:[{internalType:"uint256",name:"id",type:"uint256"},{internalType:"uint256",name:"nonce",type:"uint256"},{internalType:"uint256",name:"timestamp",type:"uint256"},{internalType:"uint256[]",name:"cumulativeDebits",type:"uint256[]"}],internalType:"struct VaultV1.ClaimTransaction",name:"claimTransaction",type:"tuple"},{internalType:"uint256",name:"timestamp",type:"uint256"},{internalType:"address",name:"requester",type:"address"}],stateMutability:"view",type:"function"},{inputs:[],name:"getChainId",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"}],name:"getRoleAdmin",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"grantRole",outputs:[],stateMutability:"nonpayable",type:"function"},{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"hasRole",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},{inputs:[{components:[{internalType:"uint256",name:"id",type:"uint256"},{internalType:"address[]",name:"addresses",type:"address[]"},{internalType:"uint256",name:"nonce",type:"uint256"},{internalType:"uint256",name:"timestamp",type:"uint256"},{internalType:"string",name:"messageForAlice",type:"string"},{internalType:"uint256[]",name:"cumulativeDebits",type:"uint256[]"},{internalType:"bytes[]",name:"signatures",type:"bytes[]"}],internalType:"struct VaultV1.ClaimRequest",name:"req",type:"tuple"}],name:"initEmergencyWithdrawAlice",outputs:[],stateMutability:"nonpayable",type:"function"},{inputs:[],name:"initEmergencyWithdrawAliceWithoutClaim",outputs:[],stateMutability:"nonpayable",type:"function"},{inputs:[{internalType:"address",name:"alice",type:"address"}],name:"initEmergencyWithdrawBob",outputs:[],stateMutability:"nonpayable",type:"function"},{inputs:[{internalType:"address",name:"tokenAddress",type:"address"},{internalType:"address",name:"serverAddress",type:"address"},{internalType:"string",name:"name",type:"string"},{internalType:"string",name:"version",type:"string"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function"},{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"renounceRole",outputs:[],stateMutability:"nonpayable",type:"function"},{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"revokeRole",outputs:[],stateMutability:"nonpayable",type:"function"},{inputs:[{components:[{internalType:"uint256",name:"id",type:"uint256"},{internalType:"address[]",name:"addresses",type:"address[]"},{internalType:"uint256",name:"nonce",type:"uint256"},{internalType:"uint256",name:"timestamp",type:"uint256"},{internalType:"string",name:"messageForAlice",type:"string"},{internalType:"uint256[]",name:"cumulativeDebits",type:"uint256[]"},{internalType:"bytes[]",name:"signatures",type:"bytes[]"}],internalType:"struct VaultV1.ClaimRequest",name:"req",type:"tuple"}],name:"stopEmergencyWithdraw",outputs:[],stateMutability:"nonpayable",type:"function"},{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},{inputs:[{components:[{internalType:"uint256",name:"id",type:"uint256"},{internalType:"address[]",name:"addresses",type:"address[]"},{internalType:"uint256",name:"nonce",type:"uint256"},{internalType:"uint256",name:"timestamp",type:"uint256"},{internalType:"string",name:"messageForAlice",type:"string"},{internalType:"uint256[]",name:"cumulativeDebits",type:"uint256[]"},{internalType:"bytes[]",name:"signatures",type:"bytes[]"}],internalType:"struct VaultV1.ClaimRequest",name:"req",type:"tuple"}],name:"verify",outputs:[],stateMutability:"view",type:"function"},{inputs:[{components:[{internalType:"uint256",name:"id",type:"uint256"},{internalType:"address[]",name:"addresses",type:"address[]"},{internalType:"uint256",name:"nonce",type:"uint256"},{internalType:"uint256",name:"timestamp",type:"uint256"},{internalType:"string",name:"messageForAlice",type:"string"},{internalType:"uint256[]",name:"cumulativeDebits",type:"uint256[]"},{internalType:"bytes[]",name:"signatures",type:"bytes[]"}],internalType:"struct VaultV1.ClaimRequest",name:"req",type:"tuple"}],name:"withdrawAlice",outputs:[],stateMutability:"nonpayable",type:"function"},{inputs:[{internalType:"address",name:"",type:"address"}],name:"withdrawTransactions",outputs:[{internalType:"uint256",name:"id",type:"uint256"},{internalType:"uint256",name:"nonce",type:"uint256"},{internalType:"uint256",name:"timestamp",type:"uint256"}],stateMutability:"view",type:"function"}];const Ve="0xA0Af3739fBC126C287D2fd0b5372d939Baa36B17",X=(e,t=Ve,n=$e)=>{const a=new x.default(e);return new a.eth.Contract(n,t)},xe=async(e,t,n)=>await e.methods[t](n).call();var M={getVaultBalance:async(e,t)=>{const n=X(t);return{balance:await xe(n,"balanceOf",e)}},withdrawConsensually:async(e,t)=>{const n=X(t),a=new x.default(t),c=e.addresses[0];try{const o=await n.methods.withdrawAlice(e).estimateGas({from:c}),He={gasPrice:await a.eth.getGasPrice(),from:c,gas:o};try{await n.methods.withdrawAlice(e).send(He).on("transactionHash",T=>{console.log("txHash",T)}).on("receipt",T=>{console.log("receipt",T)})}catch(T){throw new Error(T)}}catch(o){throw new Error(o)}}};const qe=async(e,t)=>{C.isValidNewClaim(e);{if(!A(e))throw new Error("Server's signature is not verified");if(await ee(e,t)===!0)return await $(e),u.saveConfirmedClaim(e),e;throw new Error("Server's balance is not enough")}},Q=e=>({types:{EIP712Domain:[{name:"name",type:"string"},{name:"version",type:"string"},{name:"chainId",type:"uint256"},{name:"verifyingContract",type:"address"}],Claim:[{name:"id",type:"uint256"},{name:"alice",type:"address"},{name:"bob",type:"address"},{name:"nonce",type:"uint256"},{name:"timestamp",type:"uint256"},{name:"messageForAlice",type:"string"},{name:"cumulativeDebitAlice",type:"uint256"},{name:"cumulativeDebitBob",type:"uint256"},{name:"closed",type:"uint256"}]},domain:L,primaryType:"Claim",message:{id:e.id,alice:e.addresses[0],bob:e.addresses[1],nonce:e.nonce,timestamp:e.timestamp,messageForAlice:e.messageForAlice,cumulativeDebitAlice:e.cumulativeDebits[0],cumulativeDebitBob:e.cumulativeDebits[1],closed:e.closed}}),A=(e,t=!1)=>{let n=1;t&&(n=0);const a=Q(e),c=e.signatures[n];try{return m.recoverTypedSignature({data:a,signature:c,version:m.SignTypedDataVersion.V4}).toUpperCase()===e.addresses[n].toUpperCase()}catch{return!1}},Pe=async(e,t)=>{const n=Z(e);if(C.isValidNewClaim(e),n){if(await ee(e,t)===!0)return await $(e),u.saveClaimAlice(e),e;throw new Error("Not enough balance")}},Z=e=>{const t=u.getClaimAlice();if(t&&t.id===e.id&&t.nonce>=e.nonce)throw new Error(`Claim with nonce ${e.nonce} is already signed`);return!0},ee=async(e,t)=>{const n=e.amount<0?0:1;return n===1?!0:await We(e,n,t)},We=async(e,t,n)=>{try{const{balance:a}=await M.getVaultBalance(e.addresses[t],n);return!!p.gte(a,e.cumulativeDebits[t])}catch{throw new Error("Can't get balance from Vault")}},$=async e=>{const t=Q(e),n=e.addresses[0];e.signatures[0]=await O(t,n)};var g={cashin:Pe,claimControfirmed:async e=>{if(C.isValidClaimAlice(e))if(A(e))u.saveConfirmedClaim(e);else throw new Error("Server's signature is not verified")},cashout:qe,signWithdraw:async(e,t)=>{const n=Z(e);if(C.isValidWithdraw(e)&&n)return await $(e),u.saveClaimAlice(e),e},lastClaim:e=>{const t=u.getConfirmedClaim();if(!t&&e===null)return!0;if(!t&&e&&e.nonce)return u.saveConfirmedClaim(e),!0;if(t&&e===null)return t;if(e.id>=t.id&&e.nonce>t.nonce)return A(e,!0)&&A(e)?(u.saveConfirmedClaim(e),!0):t;try{return C.areEqualClaims(e,t)===!0&&e.signatures[0]===t.signatures[0]&&e.signatures[1]===t.signatures[1]?!0:t}catch{return t}},downloadLastClaim:u.downloadLastClaim},d={cashin:async e=>{try{await y()}catch(n){throw i(r.claimNotSigned,n),n}const t=w();try{const n=await g.cashin(e,t);return l(r.claimSigned,{claim:n}),n}catch(n){throw i(r.claimNotSigned,n),n}},claimControfirmed:async e=>{try{await y()}catch(t){throw i(r.claimNotConfirmed,t),t}try{await g.claimControfirmed(e),l(r.claimConfirmed,{claim:e})}catch(t){throw i(r.claimNotConfirmed,{error:t,claim:e}),t}},cashout:async e=>{try{await y()}catch(n){throw i(r.winNotConfirmed,n),n}const t=w();try{const n=await g.cashout(e,t);return l(r.winClaimSigned,{claim:n}),n}catch(n){throw i(r.winNotConfirmed,n),n}},lastClaim:e=>{if(e&&e.hasOwnProperty("error")){i(r.claimNotSynced,e.error);return}const t=g.lastClaim(e);if(t===!0)l(r.claimSynced,"Claims are synced");else return i(r.claimNotSynced,{lastClaim:t}),t},signWithdraw:async e=>{try{await y()}catch(n){throw i(r.claimNotSigned,n),n}const t=w();try{const n=await g.signWithdraw(e,t);return l(r.claimSigned,{claim:n}),n}catch(n){throw i(r.claimNotSigned,n),n}},withdrawConsensually:async e=>{try{await y()}catch(n){throw i(r.withdraw,n),n}const t=w();try{await M.withdrawConsensually(e,t),l(r.withdraw,"Consensual withdraw is sent to blockchain")}catch(n){i(r.withdraw,n)}},getVaultBalance:async e=>{const t=w();try{return await M.getVaultBalance(e,t)}catch(n){console.error(n)}},downloadLastClaim:g.downloadLastClaim};const Ke={}.CSDK_TYPE_CASHIN,Oe={}.CSDK_TYPE_CASHOUT,Le="wallet.withdraw",Fe={}.CSDK_TYPE_HANDSHAKE;return{getAddress:me,isMetamaskInstalled:K,isRightNet:P,setRightNet:le,addEventListener:ne,receiveMsg:async e=>{if(e){const{action:t,claim:n,context:a,error:c}=JSON.parse(e);if(c)throw new Error(c);switch(t){case Fe:{const o=d.lastClaim(n);if(o)return{action:t,claim:o,context:a};break}case Ke:{if(!n.signatures[0]&&!n.signatures[1]){const o=await d.cashin(n);return{action:t,claim:o,context:a}}else n.signatures[0]&&n.signatures[1]&&await d.claimControfirmed(n);break}case Oe:{if(!n.signatures[0]&&n.signatures[1]){const o=await d.cashout(n);return{action:t,claim:o,context:a}}break}case Le:{if(!n.signatures[0]&&!n.signatures[1]){const o=await d.signWithdraw(n);return{action:t,claim:o,context:a}}else n.signatures[0]&&n.signatures[1]&&(await d.claimControfirmed(n),await d.withdrawConsensually(n));break}default:throw new Error("Not supported")}}},signChallenge:v.signChallenge,setToken:v.setToken,getToken:v.getToken,isLogged:v.isLogged,getVaultBalance:d.getVaultBalance,downloadLastClaim:d.downloadLastClaim,pay:d.cashin,payReceived:d.claimControfirmed,win:d.cashout}});
