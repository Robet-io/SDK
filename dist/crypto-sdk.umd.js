(function(o,u){typeof exports=="object"&&typeof module!="undefined"?module.exports=u(require("@metamask/eth-sig-util"),require("web3")):typeof define=="function"&&define.amd?define(["@metamask/eth-sig-util","web3"],u):(o=typeof globalThis!="undefined"?globalThis:o||self,o.cryptoSDK=u(o["@metamask/eth-sig-util"],o.Web3))})(this,function(o,u){"use strict";function M(e){return e&&typeof e=="object"&&"default"in e?e:{default:e}}var b=M(u);const T=e=>{document.addEventListener(y,e)},i=(e,t)=>{const n=new CustomEvent(y,{detail:{type:e,msg:t}});document.dispatchEvent(n)},s=(e,t)=>{const n=new CustomEvent(y,{detail:{type:e,msg:t,error:!0}});document.dispatchEvent(n)},r={network:"network",accountsChanged:"accountsChanged",chainChanged:"chainChanged",message:"message",address:"address",wrongNetworkOnGetAddress:"wrongNetworkOnGetAddress",metamaskNotInstalled:"metamaskNotInstalled",general:"general",claimNotSigned:"claimNotSigned",claimSigned:"claimSigned",paymentConfirmed:"paymentConfirmed",paymentNotConfirmed:"paymentNotConfirmed",winClaimSigned:"winClaimSigned",winNotConfirmed:"winNotConfirmed"},y="cryptoSDK",f="97",V="BSC Testnet",B="https://data-seed-prebsc-1-s1.binance.org",K="https://testnet.bscscan.com/",x="BNB",O="BNB",P="18",c=async()=>{const e=E(),t=p();if(t){const n=Number(await t.request({method:"eth_chainId"}));if(Array.isArray(e)){if(e.includes(n))return!0;{const a="Please change your network on Metamask. Valid networks are: "+g(e);throw new Error(a)}}else if(Number(n)!==Number(e)){const a=`Please set your network on Metamask to ${g(e)}`;throw new Error(a)}else return!0}},g=(e=!1)=>{const t=[];if(t[1]="Ethereum Mainnet",t[3]="Ethereum Ropsten",t[42]="Ethereum Kovan",t[4]="Ethereum Rinkeby",t[5]="Ethereum Goerli",t[56]="Binance Smart Chain",t[97]="Binance Smart Chain Testnet",e)if(Array.isArray(e)){const n=[];for(let a=0;a<e.length;a++)n.push(t[e[a]]);return n}else return t[e]?t[e]:(console.error(`Network ID ${e} Not found in the networksNames list`),g(f));else return t},E=()=>[Number(f)],N=async()=>{try{const e=await c();return i(r.network,e),e}catch(e){return s(r.network,e),!1}},L=async()=>{if(window.ethereum){const e=window.ethereum,n=[{chainId:`0x${Number(f).toString(16)}`,chainName:V,nativeCurrency:{name:x,symbol:O,decimals:P},rpcUrls:[B],blockExplorerUrls:[K]}];try{await e.request({method:"wallet_addEthereumChain",params:n}),await c()?i(r.network,"Success, network is set to the right one"):s(r.network,"Add net error: network is not changed")}catch(a){s(r.network,`Add net error: ${a}`)}}else throw window.web3?(s(r.network,"This version of Metamask supports only manual network switching"),new Error("This version of Metamask supports only manual network switching")):(s(r.network,"Metamask is not installed"),new Error("Metamask is not installed"))},p=()=>{if(window.ethereum)return window.ethereum;if(window.web3)return window.web3.currentProvider;throw s(r.metamaskNotInstalled,{error:"Metamask is not installed"}),new Error("Metamask is not installed")},S=async e=>{try{await N()?i(r.chainChanged,{chainId:e}):s(r.chainChanged,{chainId:e})}catch{s(r.chainChanged,{chainId:e})}},q=()=>{console.log("#### CSDK_CHAIN_ID","97"),window.ethereum?(window.ethereum.chainId||(window.ethereum.chainId="97"),window.ethereum.on("accountsChanged",async e=>{console.log("#### - Metamask: accountsChanged - accounts",e),i(r.accountsChanged,{accounts:e})}),window.ethereum.on("chainChanged",async e=>{console.log("#### - Metamask: chainChanged",e),await S(e)}),window.ethereum.on("message",async e=>{i(r.message,{message:e})}),window.ethereum.on("error",async e=>{console.log("#### - Metamask: error",e),s(r.error,e)})):window.web3&&(window.web3.currentProvider.on("accountsChanged",async e=>{console.log("#### - Metamask web3: accountsChanged - accounts",e),i(r.accountsChanged,{accounts:e})}),window.web3.currentProvider.on("chainIdChanged",async e=>{console.log("#### - Metamask web3: chainChanged",e),await S(e)}),window.web3.currentProvider.on("error",async e=>{console.log("#### - Metamask web3: error",e),s(r.error,e)}))},H=async()=>{if(window.ethereum){const e=await window.ethereum.request({method:"eth_requestAccounts"});if(e&&e[0])return e[0];throw new Error("Can't get address")}else if(window.web3){const e=window.web3.eth.accounts;if(e&&e.length>0)return e[0];throw new Error("Can't get address")}else throw new Error("Metamask is not installed")},k=()=>!!(window.ethereum||window.web3),U=async()=>{if(!k()){const t="Metamask is not installed, unable to get user address";throw s(r.metamaskNotInstalled,t),new Error(t)}const e=E();try{await c(e)}catch(t){throw s(r.wrongNetworkOnGetAddress,t),new Error(t)}try{return{address:await H()}}catch(t){throw s(r.address,t),new Error(t)}};q();const w={claimConfirmed:"claimConfirmed",claimAlice:"claimAlice"};var d={saveConfirmedClaim:e=>{localStorage.setItem(w.claimConfirmed,JSON.stringify(e))},getConfirmedClaim:async()=>JSON.parse(await localStorage.getItem(w.claimConfirmed)),saveClaimAlice:e=>{localStorage.setItem(w.claimAlice,JSON.stringify(e))},getClaimAlice:async()=>JSON.parse(await localStorage.getItem(w.claimAlice))};const m="0xeA085D9698651e76750F07d0dE0464476187b3ca",I=async e=>{const t=await d.getConfirmedClaim();if(t){if(t.id!==e.id)throw new Error(`Invalid claim id: ${e.id} - last claim id: ${t.id}`);if(t.nonce+1!==e.nonce)throw new Error(`Invalid claim nonce: ${e.nonce} - last claim nonce: ${t.nonce}`);if(e.addresses[1]!==m)throw new Error(`Invalid address of Server: ${e.addresses[1]} - expected: ${m}`);const a=t.cumulativeDebits[1]-t.cumulativeDebits[0]+e.amount;A(a,e.cumulativeDebits)}else{if(e.id!==1)throw new Error(`Invalid claim id: ${e.id}`);if(e.nonce!==1)throw new Error(`Invalid claim nonce: ${e.nonce}`);if(e.addresses[1]!==m)throw new Error(`Invalid address of Server: ${e.addresses[1]} - expected: ${m}`);const n=e.amount;A(n,e.cumulativeDebits)}return!0},A=(e,t)=>{if(e>0){if(t[0]!==0)throw new Error(`Invalid claim cumulative debit of Client: ${t[0]} - expected: 0`);if(t[1]!==e)throw new Error(`Invalid claim cumulative debit of Server: ${t[1]} - expected: ${e}`)}else{if(t[0]!==-e)throw new Error(`Invalid claim cumulative debit of Client: ${t[0]} - expected: ${-e}`);if(t[1]!==0)throw new Error(`Invalid claim cumulative debit of Server: ${t[1]} - expected: 0`)}},F=async e=>{let t=await I(e);if(t){const n=await d.getClaimAlice();n&&(t=J(e,n))}return t},J=(e,t)=>{if(t.id!==e.id)throw new Error(`Invalid claim id: ${e.id} - saved claim id: ${t.id}`);if(t.nonce!==e.nonce)throw new Error(`Invalid claim nonce: ${e.nonce} - saved claim nonce: ${t.nonce}`);if(t.amount!==e.amount)throw new Error(`Invalid claim amount: ${e.amount} - saved claim amount: ${t.amount}`);if(t.cumulativeDebits[0]!==e.cumulativeDebits[0])throw new Error(`Invalid claim cumulative debit of Client: ${e.cumulativeDebits[0]} - saved claim: ${t.cumulativeDebits[0]}`);if(t.cumulativeDebits[1]!==e.cumulativeDebits[1])throw new Error(`Invalid claim cumulative debit of Server: ${e.cumulativeDebits[1]} - saved claim: ${t.cumulativeDebits[1]}`);if(t.type!==e.type)throw new Error(`Invalid claim type: ${e.type} - saved claim type: ${t.type}`);if(t.addresses[0]!==e.addresses[0])throw new Error(`Invalid address of Client: ${e.addresses[0]} - saved claim: ${t.addresses[0]}`);if(t.addresses[1]!==e.addresses[1])throw new Error(`Invalid address of Server: ${e.addresses[1]} - saved claim: ${t.addresses[1]}`);return!0};var C={isValidNewClaim:I,isValidClaimAlice:F},W=[{inputs:[],stateMutability:"nonpayable",type:"constructor"},{inputs:[{internalType:"address",name:"clientAddress",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},{inputs:[{internalType:"address",name:"",type:"address"}],name:"balances",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},{inputs:[{internalType:"uint256",name:"amount",type:"uint256"}],name:"deposit",outputs:[],stateMutability:"nonpayable",type:"function"}];const G="0xBC8655Fbb4ec8E3cc9edef00f05841A776907311",Y=(e,t=G,n=W)=>{const a=new b.default(e);return new a.eth.Contract(n,t)},j=async(e,t,n)=>await e.methods[t](n).call();var X={getVaultBalance:async(e,t)=>{const n=Y(t);return{balance:new b.default().utils.fromWei(await j(n,"balanceOf",e))}}};const z="97",Q="BSC Testnet",Z="0xBC8655Fbb4ec8E3cc9edef00f05841A776907311",ee=async(e,t)=>{if(await C.isValidNewClaim(e)){if(!_(e))throw new Error("Server's signature is not verified");if(await $(e,t)===!0)return await R(e,t),d.saveConfirmedClaim(e),e;throw new Error("Server's balance is not enough")}},te={name:Q,version:"1",chainId:z,verifyingContract:Z},D=e=>({types:{EIP712Domain:[{name:"name",type:"string"},{name:"version",type:"string"},{name:"chainId",type:"uint256"},{name:"verifyingContract",type:"address"}],Claim:[{name:"id",type:"uint256"},{name:"alice",type:"address"},{name:"bob",type:"address"},{name:"nonce",type:"uint256"},{name:"timestamp",type:"uint256"},{name:"messageForAlice",type:"string"},{name:"cumulativeDebitAlice",type:"uint256"},{name:"cumulativeDebitBob",type:"uint256"}]},domain:te,primaryType:"Claim",message:{id:e.id,alice:e.addresses[0],bob:e.addresses[1],nonce:e.nonce,timestamp:e.timestamp,messageForAlice:e.messageForAlice,cumulativeDebitAlice:e.cumulativeDebits[0],cumulativeDebitBob:e.cumulativeDebits[1]}}),_=(e,t=!1)=>{let n=1;t&&(n=0);const a=D(e),h=e.signatures[n];try{return o.recoverTypedSignature({data:a,signature:h,version:o.SignTypedDataVersion.V4}).toUpperCase()===e.addresses[n].toUpperCase()}catch{return!1}},ne=async(e,t)=>{const n=await re(e);if(await C.isValidNewClaim(e)&&n){if(await $(e,t)===!0)return await R(e,t),d.saveClaimAlice(e),e;throw new Error("Not enough balance")}},re=async e=>{const t=await d.getClaimAlice();if(t&&t.id===e.id&&t.nonce>=e.nonce)throw new Error(`Claim with nonce ${e.nonce} is already signed`);return!0},$=async(e,t)=>{const n=e.amount<0?0:1;return await ae(e,n,t)},ae=async(e,t,n)=>{try{const{balance:a}=await X.getVaultBalance(e.addresses[t],n);return a>=e.cumulativeDebits[t]}catch{throw new Error("Can't get balance from Vault")}},R=async(e,t)=>{const n=D(e),a=e.addresses[0];e.signatures[0]=await t.request({method:"eth_signTypedData_v4",params:[a,JSON.stringify(n)],from:a})};var v={pay:ne,payReceived:async e=>{if(await C.isValidClaimAlice(e))if(_(e))d.saveConfirmedClaim(e);else throw new Error("Server's signature is not verified")},win:ee},l={pay:async e=>{try{await c()}catch(n){throw s(r.claimNotSigned,n),n}const t=p();try{const n=await v.pay(e,t);return i(r.claimSigned,{claim:n}),n}catch(n){throw s(r.claimNotSigned,n),n}},payReceived:async e=>{try{await c()}catch(t){throw s(r.paymentNotConfirmed,t),t}try{await v.payReceived(e),i(r.paymentConfirmed,{claim:e})}catch(t){throw s(r.paymentNotConfirmed,{error:t,claim:e}),t}},win:async e=>{try{await c()}catch(n){throw s(r.winNotConfirmed,n),n}const t=p();try{const n=await v.win(e,t);return i(r.winClaimSigned,{claim:n}),n}catch(n){throw s(r.winNotConfirmed,n),n}}};const se=async e=>{if(e){const t=JSON.parse(e);if(t&&t.type==="ticket.play"){if(!t.signatures[0]&&!t.signatures[1])return{signedClaim:await l.pay(t)};t.signatures[0]&&t.signatures[1]&&await l.payReceived(t)}else if(t&&t.type==="ticket.win"&&!t.signatures[0]&&t.signatures[1])return{signedClaim:await l.win(t)}}};return{getAddress:U,isMetamaskInstalled:k,isRightNet:N,setRightNet:L,addEventListener:T,pay:l.pay,payReceived:l.payReceived,win:l.win,receiveMsg:se}});
